// pages/api/webhooks/stripe.js
// Stripe webhook handler (recommended). Verifies signature and records checkout.session.completed
// into a checkout_sessions_completed table for authoritative records.
//
// Requires env:
// STRIPE_WEBHOOK_SECRET
// SUPABASE_URL
// SUPABASE_SERVICE_ROLE_KEY
//
// This version does NOT depend on 'micro' and reads the raw body using Node streams.
// Note: keep bodyParser disabled (export config below).

import Stripe from 'stripe';
import { createClient } from '@supabase/supabase-js';

export const config = { api: { bodyParser: false } };

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, { apiVersion: '2022-11-15' });
const supabaseAdmin = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_SERVICE_ROLE_KEY, { auth: { persistSession: false } });

// Ensure this SQL exists:
// CREATE TABLE checkout_sessions_completed (
//   id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
//   session_id text UNIQUE,
//   email text,
//   event_id text UNIQUE,
//   raw_event jsonb,
//   created_at timestamptz DEFAULT now()
// );

async function getRawBody(req) {
  return new Promise((resolve, reject) => {
    const chunks = [];
    req.on('data', (chunk) => {
      chunks.push(typeof chunk === 'string' ? Buffer.from(chunk) : chunk);
    });
    req.on('end', () => resolve(Buffer.concat(chunks)));
    req.on('error', (err) => reject(err));
  });
}

export default async function handler(req, res) {
  if (req.method !== 'POST') return res.status(405).send('Method Not Allowed');

  const sig = req.headers['stripe-signature'];
  if (!sig) return res.status(400).send('Missing stripe-signature header');

  let event;
  try {
    const buf = await getRawBody(req); // Buffer
    event = stripe.webhooks.constructEvent(buf, sig, process.env.STRIPE_WEBHOOK_SECRET);
  } catch (err) {
    console.error('Webhook signature verification failed', err);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  try {
    // Handle checkout.session.completed events
    if (event.type === 'checkout.session.completed') {
      const session = event.data.object;
      const session_id = session.id;
      const email = session.customer_email || null;

      // Insert a record (idempotent thanks to UNIQUE constraint on session_id or event_id)
      const { error: insertErr } = await supabaseAdmin
        .from('checkout_sessions_completed')
        .insert([{ session_id, email, event_id: event.id, raw_event: event }]);

      if (insertErr) {
        // If unique violation, that's fine (idempotency)
        console.error('Supabase insert checkout_sessions_completed error', insertErr);
      }
    }

    // You can also handle invoice.payment_succeeded, customer.subscription.updated etc.
    return res.status(200).send('ok');
  } catch (err) {
    console.error('Webhook handler error', err);
    return res.status(500).send('internal error');
  }
}
