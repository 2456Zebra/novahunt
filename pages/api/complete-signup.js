// pages/api/complete-signup.js
// POST { session_id, password }
// - Verifies Stripe checkout session server-side
// - Ensures session not consumed
// - Creates Supabase user via service_role key
// - Marks session as used in checkout_sessions_used table
//
// Requires env:
// SUPABASE_URL
// SUPABASE_SERVICE_ROLE_KEY
// STRIPE_SECRET_KEY
// NEXT_PUBLIC_BASE_URL (optional)

import Stripe from 'stripe';
import { createClient } from '@supabase/supabase-js';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, { apiVersion: '2022-11-15' });

const supabaseAdmin = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY,
  { auth: { persistSession: false } }
);

// Ensure this SQL exists in your Supabase DB:
// CREATE TABLE checkout_sessions_used (
//   id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
//   session_id text UNIQUE,
//   email text,
//   created_at timestamptz DEFAULT now()
// );

export default async function handler(req, res) {
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' });

  const { session_id, password } = req.body || {};
  if (!session_id || !password) return res.status(400).json({ error: 'missing session_id_or_password' });

  try {
    // 1) Retrieve Stripe Checkout Session
    const session = await stripe.checkout.sessions.retrieve(session_id, { expand: ['subscription'] });

    // 2) Verify payment/subscription success
    const paid = session.payment_status === 'paid' ||
      (session.subscription && session.subscription.status === 'active');

    if (!paid) return res.status(400).json({ error: 'payment_not_completed' });

    const email = session.customer_email;
    if (!email) return res.status(400).json({ error: 'no_email_in_session' });

    // 3) Check if this session_id has already been consumed
    const { data: existing, error: selectErr } = await supabaseAdmin
      .from('checkout_sessions_used')
      .select('id')
      .eq('session_id', session_id)
      .limit(1);

    if (selectErr) {
      console.error('Supabase select error', selectErr);
      return res.status(500).json({ error: 'db_error' });
    }

    if (existing && existing.length > 0) {
      return res.status(400).json({ error: 'session_already_used' });
    }

    // 4) Create the user in Supabase Auth (service role)
    // Note: using admin.createUser to create the account with password
    const { data: createUserData, error: createUserErr } = await supabaseAdmin.auth.admin.createUser({
      email,
      password,
      email_confirm: true, // optional: mark email confirmed immediately
    });

    if (createUserErr) {
      console.error('Supabase create user error', createUserErr);
      // If the email already exists, consider linking or returning a specific error
      return res.status(500).json({ error: 'create_user_failed', message: createUserErr.message });
    }

    // 5) Mark the session_id as used (so it cannot be replayed)
    const { error: insertErr } = await supabaseAdmin
      .from('checkout_sessions_used')
      .insert([{ session_id, email }]);

    if (insertErr) {
      console.error('Supabase insert used session error', insertErr);
      // Optionally: rollback user creation here if you need strict atomicity
      return res.status(500).json({ error: 'db_insert_failed' });
    }

    // 6) Return success. Client should now sign the user in using Supabase client.
    return res.status(200).json({ ok: true, email, user: createUserData?.user || null });
  } catch (err) {
    console.error('complete-signup error', err);
    return res.status(500).json({ error: 'server_error', message: String(err?.message || err) });
  }
}
